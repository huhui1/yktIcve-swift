//
//  PicturePreviewView.swift
//  云课堂2
//
//  Created by cc on 2018/6/6.
//  Copyright © 2018年 zqyou. All rights reserved.


import UIKit
import Alamofire
import SwiftyJSON

class PicturePreviewView: UIViewController {

    var imgurl = ""
    var imgPath = "";
    var img = #imageLiteral(resourceName: "default_slider_img.png")
    lazy var courseOpenId:String = ""
    lazy var docId:String = ""
    var MOOCCourseKJModel: MOOCCourseKJModel?
    override func viewDidLoad() {
        super.viewDidLoad()
        
        self.view.backgroundColor = UIColor.colorWithHex(hexColor: 0xf2f2f2)
        //当 id 均不为空时 为普通图片查看
        if(!self.docId.isEmpty && !self.courseOpenId.isEmpty){
            self.getviewDirectory()
            self.savestudentlog()
        }else{
           self.setUI()
        }
        // Do any additional setup after loading the view.
    }

    func getviewDirectory(){
        let dict = ["courseOpenId":self.courseOpenId,
                    "cellId":self.docId,
                    "userId":Account.defaultAccount.id!] as [String : Any]
        XLBallLoading.show(in: self.view)
        Alamofire.request(MOOCAPI.Mooc_coursestudy_viewDirectory, method: .post, parameters: dict, encoding: URLEncoding.default).responseJSON { response in
            if let value = response.result.value {
                let json = JSON(value)
                XLBallLoading.hide(in: self.view)
                if json["code"] == 1{
                    let urls = JSON.init(parseJSON: json["resUrl"].stringValue)
                    self.imgurl = urls["urls"]["preview_oss_ori"].stringValue
                    if(self.imgurl.isEmpty){
                       self.imgurl = urls["urls"]["preview"].stringValue
                    }
                    self.setUI()
                }else{
                    //ZKProgressHUD.showError(json["msg"].stringValue);
                }
            }else{
                XLBallLoading.hide(in: self.view)
                ZKProgressHUD.showMessage("网络环境异常请稍后再试！")
            }
        }
    }

    //记录PPT日志
    func savestudentlog(){
        let dict = ["courseOpenId":self.courseOpenId,
                    "cellId":self.docId,
                    "auvideoLength":"0",
                    "videoTimeTotalLong":"0",
                    "userId":Account.defaultAccount.id!] as [String : Any]
        Alamofire.request(MOOCAPI.coursestudy_statStuProcessCellLogAndTimeLong, method: .post, parameters: dict, encoding: URLEncoding.default).responseJSON { response in
            if let value = response.result.value {
                let json = JSON(value)
                if json["code"] == 1{
                    if json["isStudy"].boolValue{
                        //已学习
                        self.MOOCCourseKJModel?.cellRefresh = "cellRefresh"
                    }
                }else{
                    //ZKProgressHUD.showError(json["msg"].stringValue);
                }
            }else{
                ZKProgressHUD.showMessage("网络环境异常请稍后再试！")
            }
        }
    }
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }

    @objc func back(){
        self.navigationController?.popViewController(animated: true)
    }
    fileprivate func setUI(){
        let item = UIBarButtonItem(title: "\u{e6f7}返回", style: .plain, target: self, action: #selector(self.back))
        self.navigationItem.leftBarButtonItem = item
        common.share.setBackButtonItem(item:item)
        
        self.view.addSubview(self.imgview)
        self.imgview.image =  UIImage(contentsOfFile: self.file)
        self.imgview.frame = self.view.frame
        self.imgview.center = self.view.center
        self.imgview.contentMode = .scaleAspectFit
        self.imgview.isUserInteractionEnabled = true
        let pan = UIPanGestureRecognizer(target: self,action: #selector(self.mobile(_:)))
        let PinchGesture = UIPinchGestureRecognizer.init(target: self, action: #selector(self.shrink(_:)));
        self.imgview.addGestureRecognizer(pan)
        self.imgview.addGestureRecognizer(PinchGesture)
        let imageTapGesture = UITapGestureRecognizer.init(target: self, action: #selector(self.touch_image(sender:)));
        self.imgview.addGestureRecognizer(imageTapGesture);
        if(!self.imgurl.isEmpty){
             common.share.setSDImg(str: self.imgurl, imgview: self.imgview )
        }else if(!self.imgPath.isEmpty){
            self.imgview.image = UIImage.init(named: self.imgPath)
        }else{
             self.imgview.image = img
        }

        
    }
    
    
    @objc func touch_image(sender: UITapGestureRecognizer) {
      //  self.presentingViewController?.dismiss(animated: false, completion: nil)
        
    }
    
    @objc func mobile(_ sender: UIPanGestureRecognizer) {
        let translate = sender.translation(in: self.view)
        
        //平移后的位置
        var centerX = self.imgview.center.x + translate.x
        var centerY = self.imgview.center.y + translate.y
        boundCenter(centerX: &centerX, centerY: &centerY)
        self.imgview.center = CGPoint(x:centerX,y:centerY)
        
        sender.setTranslation(CGPoint.zero, in: self.view)
        
    }
    
    @objc func shrink(_ sender: UIPinchGestureRecognizer) {
        
        lastScale *= sender.scale
        
        //禁止过大过小
        if lastScale > SCALE_MAX {
            lastScale = SCALE_MAX
        }else if lastScale < SCALE_MIN {
            lastScale = SCALE_MIN
        }
        
        self.imgview.transform = self.view.transform.scaledBy(x: lastScale,y: lastScale)
        sender.scale = 1
        
        //平移后的位置
        var centerX =  self.imgview.center.x
        var centerY =  self.imgview.center.y
        boundCenter(centerX: &centerX, centerY: &centerY)
        self.imgview.center = CGPoint(x:centerX,y:centerY)
    }
    
    
    // 限制iamgeView中心的位置
    //当图片大于屏幕时,平移图片时防止平移过头
    func boundCenter( centerX:inout CGFloat, centerY:inout CGFloat){
        let mainFrame = self.view.frame
        let imageFrame = self.imgview.frame
        
        if imageFrame.width < mainFrame.width {
            centerX = mainFrame.width / 2
        }else{
            let xMin = mainFrame.width - imageFrame.size.width / 2
            let xMax = imageFrame.size.width / 2
            if centerX > xMax {
                centerX = xMax
            }else if centerX < xMin {
                centerX = xMin
            }
        }
        
        if imageFrame.height < mainFrame.height {
            centerY = mainFrame.height  / 2
        }else{
            let yMin = mainFrame.height - imageFrame.size.height / 2
            let yMax = imageFrame.size.height  / 2
            if centerY > yMax {
                centerY = yMax
            }else if centerY < yMin {
                centerY = yMin
            }
        }
    }
    
    
    var lastScale:CGFloat = 1
    var SCALE_MAX:CGFloat = 3
    var SCALE_MIN:CGFloat = 1
    
    fileprivate  let height = UIScreen.main.bounds.height;
    
    lazy var file :String = {
        return "";
    }()
    
    fileprivate lazy var imgview :UIImageView = {
        var img = UIImageView()
        return img;
    }()

}
