//
//  groupHomeworkView.swift
//  云课堂2
//  小组作业
//  Created by 尤增强 on 2018/7/6.
//  Copyright © 2018年 zqyou. All rights reserved.
//

import UIKit
import  SwiftyJSON
import Alamofire
import MobileCoreServices
import SCLAlertView

class groupHomeworkView: UIViewController,UITextViewDelegate {
    @IBOutlet weak var Collection: UICollectionView!
    @IBOutlet var Btn_Submit: UIButton!
    @IBOutlet var Btn_SaveDrafts: UIButton!
    @IBOutlet weak var stuCollectionView: UICollectionView!
    @IBOutlet weak var collectionSizeH: NSLayoutConstraint!
    @IBOutlet weak var contentView: UIView!
    @IBOutlet weak var lab_remark: UILabel!
    @IBOutlet weak var contentSizeH: NSLayoutConstraint!
    @IBOutlet weak var textViewSzieH: NSLayoutConstraint!
    
    @IBOutlet weak var textView: UITextView!
    
    var ztWay = 1
    var codeTimer: DispatchSourceTimer?
    lazy var useTime :Int = {
        return 0
    }()
    //键盘的监听移除
    var keyboardPush = false
    lazy var isPushed:Bool = {
        return false
    }()
    //最大图片数
    let maxImgCount = 9
    lazy var answer_time:Int = 0
    lazy var ischeck:Bool = false//是否批改
    lazy var courseOpenId: String = {
        return""
    }()
    lazy var openClassId: String = {
        return ""
    }()
    lazy var homeWorkId: String = {
        return ""
    }()
  
    lazy var homeworkTermTimeId: String = {
        return ""
    }()
    lazy var homeworktitle: String = {
        return ""
    }()
    lazy var homeworkStuId: String = {
        return ""
    }()

    lazy var stuAnswerPreviewUrl: String = {
        return ""
    }()

    lazy var stuAnswerUploadUrl: String = {
        return ""
    }()
    lazy var workTitle : String = {
        return ""
    }()
    var  questionsFile = [JSON]()
    var  studentAnswer = [UploadDocModel]()
    var toolBar = UIToolbar();
    
    
    override func viewDidLoad() {
        if self.ischeck{
            self.Btn_Submit.isHidden = true
            self.Btn_SaveDrafts.isHidden = true
        }
        
        super.viewDidLoad()
        self.setCollectionUI()
        self.getData()
        self.title = self.homeworktitle
        self.lab_remark.text = self.homeworktitle
        // Do any additional setup after loading the view.
        let item = UIBarButtonItem(title: "返回", style: .plain, target: self, action: nil)
        self.navigationItem.backBarButtonItem = item
    }
    init() {
        super.init(nibName: "groupHomeworkView", bundle: nil)
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }

    override func viewDidLayoutSubviews() {

    }


    @IBAction func saveHomework(_ sender: UIButton) {
        
        self.submitHomework(isDraft: 1)
    }

    @IBAction func submitHomework(_ sender: UIButton) {
        let alert = SCLAlertView()

        alert.addButton("确定") {
            self.submitHomework(isDraft: 0)
        }
        alert.showInfo("提交作业", subTitle: "确定提交该作业吗？",closeButtonTitle: "取消")
    }
    
    
    
    override func viewWillDisappear(_ animated: Bool) {
     
        if(!self.isPushed){
            self.codeTimer?.cancel()
        }
        self.isPushed = false
        
    }
    func setTime(){
        
        // 在global线程里创建一个时间源
        codeTimer = DispatchSource.makeTimerSource(queue:  DispatchQueue.global())
        // 设定这个时间源是每秒循环一次，立即开始
        codeTimer?.schedule(deadline: .now(), repeating: .seconds(1))
        // 设定时间源的触发事件
        codeTimer?.setEventHandler(handler: {
            // 每秒计时一次
            self.useTime = self.useTime + 1
            // 返回主线程处理一些事件，更新UI等等
            DispatchQueue.main.async {
                let  seconds = self.useTime % 60;
                let  minutes = Int(self.useTime / 60);
                let title =  "\(minutes):\(seconds)";
                self.answer_time = minutes * 60 + seconds
                self.title = title
            }
        })
        // 启动时间源
        codeTimer?.resume()
    }
    
    func setTextView(){
        //监听键盘弹出通知
        NotificationCenter.default
            .addObserver(self,selector: #selector(keyboardWillShow(_:)),
                         name: NSNotification.Name.UIKeyboardWillShow, object: nil)
        //监听键盘隐藏通知
        NotificationCenter.default
            .addObserver(self,selector: #selector(keyboardWillHide(_:)),
                         name: NSNotification.Name.UIKeyboardWillHide, object: nil)
        //键盘
        toolBar = common.share.AddToolKeyboardDoneBar()
        let doneButton = UIBarButtonItem(title: "确定", style: .plain, target: self, action: #selector(self.DoneClick));
        let spaceButton = UIBarButtonItem(barButtonSystemItem: .flexibleSpace, target: nil, action: nil)
        toolBar.setItems([spaceButton,doneButton], animated: false);
        if ztWay == 5{
            self.textViewSzieH.constant = 0
        }
        if self.textView.text.isEmpty{
            self.textView.text = "请输入回答内容"
            self.textView.textColor = UIColor.gray
        }
        self.textView.delegate = self
    }
    func textViewShouldBeginEditing(_ textView: UITextView) -> Bool {
        if (textView.text == "请输入回答内容"){
            textView.text = ""
            self.textView.textColor = UIColor.black
        }
        textView.inputAccessoryView = toolBar;
        return true
    }
    @objc func DoneClick(){
        self.view.endEditing(true)
    }
    // 键盘显示
    @objc func keyboardWillShow(_ notification: Notification) {
        
        let userInfo = (notification as NSNotification).userInfo!
        //键盘尺寸
        let keyboardSize = (userInfo[UIKeyboardFrameBeginUserInfoKey]
            as! NSValue).cgRectValue
        var contentInsets:UIEdgeInsets
        
        contentInsets = UIEdgeInsetsMake(64.0, 0.0, (keyboardSize.height), 0.0);
        
         self.view.frame = CGRect.init(x:0, y: -64, width:self.view.bounds.width, height: self.view.bounds.height);
        
    }
    
    // 键盘隐藏
    @objc func keyboardWillHide(_ notification: Notification) {
        
         self.view.frame = CGRect.init(x:0, y: 64, width:self.view.bounds.width, height: self.view.bounds.height);
    }
    //移除监听
    override func viewDidDisappear(_ animated: Bool) {
        if(!self.keyboardPush){
//            NotificationCenter.default.removeObserver(self)
            NotificationCenter.default.removeObserver(self, name: NSNotification.Name.UIKeyboardWillShow, object: nil)
            NotificationCenter.default.removeObserver(self, name: NSNotification.Name.UIKeyboardWillHide, object: nil)
        }
        self.keyboardPush = false
    }
    /*
    // MARK: - Navigation

    // In a storyboard-based application, you will often want to do a little preparation before navigation
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        // Get the new view controller using segue.destinationViewController.
        // Pass the selected object to the new view controller.
    }
    */

}
extension groupHomeworkView:UICollectionViewDelegate,UICollectionViewDataSource{

    func setCollectionUI(){

        self.lab_remark.text = self.workTitle

        self.Collection.register(UINib.init(nibName: "itemImgCell", bundle: Bundle.main), forCellWithReuseIdentifier: "itemImgCell")

        self.Collection.delegate = self
        self.Collection.dataSource = self
        
        self.stuCollectionView.delegate = self
        self.stuCollectionView.dataSource = self

    }

    func  collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {

        if(collectionView == self.Collection){
              let j  =  self.questionsFile[indexPath.row]
            self.getFileById(Id:j["Id"].stringValue)
        }else if(collectionView == self.stuCollectionView){
              let m  =  self.studentAnswer[indexPath.row]
            self.getFileByUrl(URL: m.docUrl)
        }
    }

    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {

        if(collectionView == self.Collection){
            return self.questionsFile.count
        }else{
            return self.studentAnswer.count
        }

    }

    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {

        if(collectionView == self.Collection){
            let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "itemImgCell",
                                                          for: indexPath) as! itemImgCell
            let j  =  self.questionsFile[indexPath.row]
            common.share.setSDImg(str:j["docOssThumbnail"].stringValue, imgview: cell.thumbnail)
            return cell
        }else {
        
            let j  =  self.studentAnswer[indexPath.row]
            let d = Date()
            let identifier = "cell\(d.timeIntervalSince1970)"
            self.stuCollectionView.register(UINib.init(nibName: "ZQUICollectionViewCell_Img", bundle: Bundle.main), forCellWithReuseIdentifier: identifier)
            let cell = collectionView.dequeueReusableCell(withReuseIdentifier: identifier,for: indexPath) as! ZQUICollectionViewCell_Img

           
            cell.CellBlock = {  () -> Void in
                self.uploadImg()
            }
            cell.btn_del.tag = indexPath.row
            cell.btn_del.addTarget(self, action: #selector(self.deleteSelfAnswer), for: .touchUpInside)
            cell.setModelByHomeworkFile(Model: j)
            return cell
        }

    }
    
    @objc func deleteSelfAnswer(_ btn:UIButton){
        let alertController = UIAlertController(title: "提示",
                                                message:"是否删除图片", preferredStyle: .alert)
        let cancelAction = UIAlertAction(title: "取消", style: .cancel, handler: nil)
        
        let okAction = UIAlertAction(title: "确定", style: .destructive, handler: {
            action in
                let tag = btn.tag
                print(tag)
                print(self.studentAnswer.count)

                        let id = self.studentAnswer[tag].Id
                        self.deleteCommentaryFileById(Id:id )
                

                self.studentAnswer.remove(at: tag)
            
                if self.ztWay == 3{
                    if(self.studentAnswer.count < self.maxImgCount){
                        let v = self.studentAnswer[0]
                        if !v.url.isEmpty{
                        let  m = UploadDocModel.init(data: JSON(), img:UIImage.init(named: "scancode_photo")!)
                            m.isAdd = true
                        self.studentAnswer.insert(m, at: 0)
                        }
                    }
                }else{
                    var IsMyImgCount = 0
                    for i in self.studentAnswer{
                        if i.IsMyFile{
                            IsMyImgCount = IsMyImgCount + 1
                        }
                    }
                    if(IsMyImgCount < self.maxImgCount){
                        let v = self.studentAnswer[0]
                        if !v.url.isEmpty{
                            let  m = UploadDocModel.init(data: JSON(), img:UIImage.init(named: "scancode_photo")!)
                              m.isAdd = true
                            self.studentAnswer.insert(m, at: 0)
                        }
                    }
                    
               }
                self.stuCollectionView.reloadData()
        })
        alertController.addAction(cancelAction)
        alertController.addAction(okAction)
        self.present(alertController, animated: true, completion: nil)
    }
}

extension groupHomeworkView:UIImagePickerControllerDelegate,UINavigationControllerDelegate {

    //底部弹窗
    func uploadImg(){
        //判断是否开启打开相册权限
        if(!common.share.isAuthorizePhotos()){
            common.share.authorizePhotos()
        }else{
            self.upload()
        }
    }
    //底部弹窗
    func upload(){

        let userIconAlert = UIAlertController(title: "请选择操作", message: "", preferredStyle: UIAlertControllerStyle.actionSheet)

        let chooseFromPhotoAlbum = UIAlertAction(title: "从相册选择", style: UIAlertActionStyle.default, handler: funcChooseFromPhotoAlbum)
        userIconAlert.addAction(chooseFromPhotoAlbum)

        let chooseFromPhotoVideo = UIAlertAction(title: "视频", style: UIAlertActionStyle.default, handler: funcChooseFromPhotoVideo)
        userIconAlert.addAction(chooseFromPhotoVideo)

        let chooseFromCamera = UIAlertAction(title: "拍照", style: UIAlertActionStyle.default,handler:funcChooseFromCamera)
        userIconAlert.addAction(chooseFromCamera)

        let canelAction = UIAlertAction(title: "取消", style: UIAlertActionStyle.cancel,handler: nil)
        userIconAlert.addAction(canelAction)

        if(UIDevice.current.model == "iPad")
        {
            let mine = UIView.init(frame: CGRect(x:self.view.bounds.width/2,y:self.view.bounds.height,width:20,height:20))
            self.view.addSubview(mine)
            let popPresenter =  userIconAlert.popoverPresentationController

            popPresenter?.sourceView = mine
            popPresenter?.sourceRect = mine.bounds
            self.isPushed = true
            self.keyboardPush = true
            self.present(userIconAlert, animated: true, completion: nil)
        }
        else{
            self.isPushed = true
            self.keyboardPush = true
            self.present(userIconAlert, animated: true, completion: nil)
        }
    }
    //从相册选择照片
    func funcChooseFromPhotoAlbum(_ avc:UIAlertAction) -> Void{


        let masterVC = HsuAlbumMasterTableViewController()
        let navi = UINavigationController(rootViewController: masterVC)
        masterVC.title = "图片"
        let gridVC = HsuAssetGridViewController()
        gridVC.title = "所有图片"
        let leftBarBtn = UIBarButtonItem(title: "", style: .plain, target: self,
                                         action:nil)
        gridVC.navigationItem.leftBarButtonItem = leftBarBtn
        navi.pushViewController(gridVC, animated: false)

        UIDevice.current.setValue(UIInterfaceOrientation.landscapeLeft.rawValue, forKey: "orientation")
        self.isPushed = true
        self.keyboardPush = true
        present(navi, animated: true)

        HandleSelectionPhotosManager.share.getSelectedPhotos(with: 1) { (assets, images) in
            self.upload(img: images[0])
        }


    }
    func funcChooseFromCamera(_ avc:UIAlertAction) -> Void{
        if UIImagePickerController.isSourceTypeAvailable(UIImagePickerControllerSourceType.camera) {
            let imagePicker = UIImagePickerController()

            //设置代理
            imagePicker.delegate = self as UIImagePickerControllerDelegate & UINavigationControllerDelegate
            //            imagePicker.delegate = self
            //允许编辑
            imagePicker.isEditing = false;
            //设置图片源
            imagePicker.sourceType = UIImagePickerControllerSourceType.camera
            //模态弹出IamgePickerView
            self.isPushed = true
            self.keyboardPush = true
            self.present(imagePicker, animated: true, completion: nil)

        }else{
            print("模拟器不支持拍照功能")
        }
    }
    func imagePickerControllerDidCancel(_ picker: UIImagePickerController){
        picker.dismiss(animated: true, completion: nil)
    }

    func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) {
        //获取照片的原图
        if let image :UIImage = (info as NSDictionary).object(forKey: UIImagePickerControllerOriginalImage)as?UIImage{
            //获得编辑后的图片
            //let image = (info as NSDictionary).object(forKey: UIImagePickerControllerEditedImage)as!UIImage
            self.upload(img: image);
        }else{
            let videoURL = info[UIImagePickerControllerMediaURL] as! URL
            self.getVideoOne(url: videoURL)
        }

        picker.dismiss(animated: true, completion: nil)
    }

    //上传
    func upload(img:UIImage)
    {

        let fileManager = FileManager.default
        let rootPath = NSSearchPathForDirectoriesInDomains(.documentDirectory,
                                                           .userDomainMask, true)[0] as String
        let date = NSDate(),
        timeInterval = date.timeIntervalSince1970 * 1000
        let filePath = "\(rootPath)/" + String(timeInterval) + ".jpg"
        let  imageData =  common.share.resetImgSize(sourceImage: img, maxImageLenght: 0, maxSizeKB: 200)
        fileManager.createFile(atPath: filePath, contents: imageData, attributes: nil)
        let imageNSURL = URL.init(fileURLWithPath: filePath)
        ZKProgressHUD.show("0 %")
        Alamofire.upload(multipartFormData: { multipartFormData in
            multipartFormData.append(imageNSURL, withName: "file1")
        },to: self.stuAnswerUploadUrl,encodingCompletion: { encodingResult in
            switch encodingResult {
            case .success(let upload, _, _):
                upload.responseJSON { response in
                    let result = JSON(response.result.value ?? "");
                     self.setModelToList(result: result, type:"jpg", docTitle: "\(timeInterval).jpg")
                    ZKProgressHUD.hide(delay: 0)
                    }.uploadProgress { progress in // main queue by default
                        // print("当前进度: \(progress.fractionCompleted)")
                        ZKProgressHUD.show("\(String(format: "%.1f", progress.fractionCompleted * 100)) %")
                }
            case .failure(let encodingError):
                print(encodingError)
            }
        })
    }

    //从相册选择视频
    func funcChooseFromPhotoVideo(_ avc:UIAlertAction) -> Void{


        if UIImagePickerController.isSourceTypeAvailable(.photoLibrary) {
            //初始化图片控制器
            let imagePicker = UIImagePickerController()
            //设置代理
            imagePicker.delegate = self
            //指定图片控制器类型
            imagePicker.sourceType = .photoLibrary
            //只显示视频类型的文件
            imagePicker.mediaTypes = [kUTTypeMovie as String]
            //不需要编辑
            imagePicker.allowsEditing = false

            UIDevice.current.setValue(UIInterfaceOrientation.landscapeLeft.rawValue, forKey: "orientation")
            //弹出控制器，显示界面
            self.isPushed = true
            self.keyboardPush = true
            self.present(imagePicker, animated: true, completion: nil)
        }
        else {
            print("读取相册错误")
        }

    }


    //处理
    func getVideoOne(url:URL) {

        XLBallLoading.show(in: self.stuCollectionView)

        Alamofire.upload(multipartFormData: { multipartFormData in
            multipartFormData.append(url, withName: "file1")
        },to: self.stuAnswerUploadUrl,encodingCompletion: { encodingResult in
            switch encodingResult {
            case .success(let upload, _, _):
                upload.responseJSON { response in
                        let result = JSON(response.result.value ?? "");

                        self.setModelToList(result: result,type:"mp4", docTitle: "file1")
                        XLBallLoading.hide(in: self.stuCollectionView)
                    }.uploadProgress { progress in // main queue by default
//                         ZKProgressHUD.show("\(String(format: "%.1f", progress.fractionCompleted * 100)) %")
                }
            case .failure(let encodingError):
                print(encodingError)
            }
        })
    }

    //model加入数组
    func setModelToList(result:JSON,type:String,docTitle:String){

        let m = UploadDocModel.init(data: result, previewUrl: self.stuAnswerPreviewUrl, type: type, docTitle: docTitle,IsMyFile:true)
        self.studentAnswer.append(m)
        
        if self.ztWay == 3{
            if(self.studentAnswer.count == self.maxImgCount + 1){
                self.studentAnswer.remove(at: 0)
            }
        }else{
            var IsMyImgCount = 0
            for i in studentAnswer{
                if i.IsMyFile{
                    IsMyImgCount = IsMyImgCount + 1
                }
            }
            if(IsMyImgCount == self.maxImgCount){
                self.studentAnswer.remove(at: 0)
            }
        }
        
        self.stuCollectionView.reloadData()

    }
}

