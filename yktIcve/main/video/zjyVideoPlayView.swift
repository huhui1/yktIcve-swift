//
//  zjyVideoPlayView.swift
//  云课堂2
//
//  Created by 尤增强 on 2018/7/3.
//  Copyright © 2018年 zqyou. All rights reserved.
//

import UIKit
import BMPlayer
import AVFoundation
import NVActivityIndicatorView
import SwiftyJSON

class zjyVideoPlayView: UIViewController {
    
    var isStu = false
    var slideMenu:SlideMenu?
    let appDelegate = UIApplication.shared.delegate as! AppDelegate
    lazy var courseOpenId:String = ""
    lazy var docId:String = ""
    var openClassId = "";
    var moduleId = ""
    var isStudyFinish = false
    lazy var enterTime:Int = 0
    lazy var studyCellTime:Int = 0
    lazy var stuCellPicCount:Int = 0
    lazy var cellLogId:String = ""
    var token = "" //学习课件的token,用于记录日志
    lazy var videoPlayurl:String = ""
    lazy var videotittle:String = ""
    lazy var Watchtime:Double = 0.0//当前观看时长
    lazy var WatchMaxtime:Double = 0.0 //视频观看的最大时长
    lazy var videototalTime:Double = 0.0
    var docvideoleavelist = [KJloctoionModel]();
    lazy var leavelocation:Int = 0     //离开时的位置
    var sqliteContext = SQLiteManagerKJrecord()
    let reachability = Reachability()
    var StuCourseKJModel: ZJY_StuCourseKJModel?
    var isPushed = false
    var isNeedUpdate = false
    /// 是否可以下载
    var isAllowDownLoad = false
    //存储url数组
    lazy var videourls = [String]()
    let  player = BMPlayer()
    var courseBBSAction = CourseBBSAction.init(ActionName: "")
    let vc1 = KJCourseTeachingTableView()
    let vc2 = courseBBSEvaluationView()
    let vc3 = courseBBSQuestionView()
    let vc4 = courseBBSNoteView()
    let vc5 = courseBBSErrorView()
    let vc6 = StatisticallearningView()
    override func viewDidLoad() {
        super.viewDidLoad()
        self.docvideoleavelist = [sqliteContext.readOneData(_userId: Account.defaultAccount.id!,docId:  self.docId)]
        if !self.isStu{
            let item = self.docvideoleavelist[0]
            self.leavelocation = item.location //上次离开时的位置
        }
        if self.leavelocation != 0{
            self.WatchMaxtime = Double(self.leavelocation)
        }
        self.resetPlayerManager()
        self.courseBBSAction.addObserver(self, forKeyPath: "ActionName", options: [.new, .old], context: nil)
        self.view.backgroundColor = UIColor.colorWithHex(hexColor: 0xf2f2f2)
        self.setVideo()
        //判断网络
        self.NetWorkState()
        self.setvideoUrl()
    }
 
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        UIApplication.shared.setStatusBarStyle(UIStatusBarStyle.default, animated: false)

        self.isPushed = false
      
        // 使用手势返回的时候，调用下面方法
        player.pause(allowAutoPlay: true)
        appDelegate.isEffective = true

        let item = self.docvideoleavelist[0]
        if item.id.isEmpty{
            //插入数据
            sqliteContext.insertData(_id: self.docId, _userId:Account.defaultAccount.id!, _location:Int(self.Watchtime))
        }else{
            print("\(self.Watchtime)========================================")
            sqliteContext.updateData(Id: self.docId, _location: Int(self.Watchtime))
        }
        self.studyCellTime = common.share.returntime(timeStart: enterTime, timeEnd:
            common.share.getNowdate())
       
        self.savePlayLog()
        self.navigationController?.navigationBar.isHidden = false
    }

    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        self.enterTime = common.share.getNowdate()
        appDelegate.isEffective = false
        self.navigationController?.navigationBar.isHidden = true
        UIApplication.shared.setStatusBarStyle(UIStatusBarStyle.lightContent, animated: false)
        // If use the slide to back, remember to call this method
        // 使用手势返回的时候，调用下面方法
        player.autoPlay()
    }

    fileprivate func setVideo(){

        view.addSubview(player)
        player.snp.makeConstraints { (make) in
            make.top.equalTo(self.view)
            make.left.right.equalTo(self.view)
            // Note here, the aspect ratio 16:9 priority is lower than 1000 on the line, because the 4S iPhone aspect ratio is not 16:9
            make.height.equalTo(player.snp.width).multipliedBy(9.0/16.0).priority(750)
        }
        // Back button event
        player.backBlock = { [unowned self] (isFullScreen) in
            if isFullScreen == true && UIDevice.current.model != "iPad" { return }
            let _ = self.navigationController?.popViewController(animated: true)
            let dict = ["type":"closeRes"]
            self.emitToPC(dict:dict)
        }

        player.delegate = self
        self.setSlideMenu()
    }

    func setSlideMenu(){

        var titles = [String]()
        var arr:Array<UIViewController> = [];
        if isStu{
            titles = ["评价","问答","笔记","纠错"]
            arr = [vc2,vc3,vc4,vc5]
        }else{
            titles = ["课堂教学","评价","问答","笔记","纠错","学习统计"]
            arr = [vc1,vc2,vc3,vc4,vc5,vc6]
        }

        vc1.courseOpenId = self.courseOpenId
        vc1.openClassId = self.openClassId
        vc1.isMusicAndVideo = true
        vc1.activeType = 5
        vc1.courseBBSAction = self.courseBBSAction

        vc2.courseOpenId = self.courseOpenId
        vc2.activeType = 1
        vc2.openClassId = self.openClassId
        vc2.cellId = self.docId
        vc2.courseBBSAction = self.courseBBSAction

        vc3.courseOpenId = self.courseOpenId
        vc3.activeType = 2
        vc3.openClassId = self.openClassId
        vc3.cellId = self.docId
        vc3.courseBBSAction = self.courseBBSAction

        vc4.courseOpenId = self.courseOpenId
        vc4.activeType = 3
        vc4.openClassId = self.openClassId
        vc4.cellId = self.docId
        vc4.courseBBSAction = self.courseBBSAction

        vc5.courseOpenId = self.courseOpenId
        vc5.activeType = 4
        vc5.openClassId = self.openClassId
        vc5.cellId = self.docId
        vc5.courseBBSAction = self.courseBBSAction

        vc6.cellId = self.docId
        vc6.isMusicAndVideo = true
        vc6.openClassId = self.openClassId

        
        var ht = 0
        if common.share.isX(){
            ht = 30
        }
        
        let h = UIScreen.main.bounds.width / 16 * 9
        slideMenu = SlideMenu(frame: CGRect(x:0,y:h + 2 ,width:view.frame.width,height:40), titles:titles, childControllers:arr)
        slideMenu?.backgroundColor = UIColor.white
        slideMenu?.bodyFrame = CGRect.init(x: 0, y:h + 42, width: view.frame.width, height: view.frame.height - 40 - h)
         vc2.f =  CGRect.init(x: 0, y:0, width: view.frame.width, height: view.frame.height - 40 - h - CGFloat(ht))
         vc3.f =  CGRect.init(x: 0, y:0, width: view.frame.width, height: view.frame.height - 40 - h - CGFloat(ht))
         vc4.f =  CGRect.init(x: 0, y:0, width: view.frame.width, height: view.frame.height - 40 - h - CGFloat(ht))
         vc5.f =  CGRect.init(x: 0, y:0, width: view.frame.width, height: view.frame.height - 40 - h - CGFloat(ht))
        slideMenu?.selectedColor = UIColor(red: 6/255, green: 163/255, blue: 121/255, alpha: 1);

        slideMenu?.isFixed = true;
        slideMenu?.indicatorStyle = .followText;
        slideMenu?.titleStyle = .transfrom;
        slideMenu?.line.isHidden = false;
        slideMenu?.scrollToIndex(0)
        view.addSubview(slideMenu!)
        
    }

    override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {
        if keyPath == "ActionName" {

            self.actionBBSType()
        }
    }

    //添加监听后,使用完必须移除监听(一个add 对应一个 remove)
    deinit {
        self.courseBBSAction.removeObserver(self, forKeyPath: "ActionName", context: nil)
    }
    @objc func actionBBSType(){

        switch (self.courseBBSAction.ActionName) {
        case "create":
            let vc = createCourseBBSView()
            vc.courseOpenId = self.courseOpenId
            vc.openClassId = self.openClassId
            vc.cellId = self.docId
            vc.courseBBSAction = self.courseBBSAction
            vc.activeType = "\(self.courseBBSAction.actionType)"
            self.navigationController?.pushViewController(vc, animated: true)
        case "details":
            let vc = CourseBBSDetailsView()
            vc.activeType = (self.courseBBSAction.actionType)
            vc.cellId = self.docId
            vc.openClassId = self.openClassId
            vc.courseOpenId = self.courseOpenId
            vc.evaluation = self.courseBBSAction._evaluationModel!
            vc.courseBBSAction = self.courseBBSAction
            vc.isMainTeacher = self.courseBBSAction.isMainTeacher == true ? 1 : 0
            self.navigationController?.pushViewController(vc, animated: true)
        case "teaching":
            let vc = faceInfoView();
            vc.faceTimeStatus = self.courseBBSAction.faceTimeStatus
            vc.activityId =   self.courseBBSAction.activityId
            vc.courseOpenId =  self.courseOpenId
            vc.openClassIds =   self.courseBBSAction.openClassIds

            self.navigationController?.pushViewController(vc, animated: true);
        case "refresh":
            switch (self.courseBBSAction.actionType){
            case 1:
                vc2._BBSViewModel.getBBSData()
            case 2:
                vc3._BBSViewModel.getBBSData()
            case 3:
                vc4._BBSViewModel.getBBSData()
            case 4:
                vc5._BBSViewModel.getBBSData()
            case 5:
                vc1.getData()
                print("==")
            default:
                print("")
            }
        case "edit":
            print("编辑")
            let vc = createFaceView()
            vc.title = "编辑课堂教学"
            vc.activityId = self.courseBBSAction.activityId
            vc.openClassId = self.openClassId
            vc.courseOpenId = self.courseOpenId
            vc.textTitle.text = self.courseBBSAction.textTitle
            vc.textPlace.text = self.courseBBSAction.textPlace
            vc.startDtae.text = self.courseBBSAction.startDtae
            vc.ClassSection.text = self.courseBBSAction.ClassSection
            vc.courseBBSAction = self.courseBBSAction
            vc.video = true
            vc.hidesBottomBarWhenPushed = true
            self.navigationController?.pushViewController(vc, animated: true);
        default:
            print("_____")
        }

    }

    func resetPlayerManager() {
        BMPlayerConf.allowLog = false
        BMPlayerConf.shouldAutoPlay = true
        BMPlayerConf.tintColor = UIColor.white
        BMPlayerConf.topBarShowInCase = .always
        BMPlayerConf.loaderType  = NVActivityIndicatorType.ballRotateChase
    }
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
}

// MARK:- BMPlayerDelegate example
extension zjyVideoPlayView: BMPlayerDelegate{
    
    func bmPlayerStartDownload() {
        if(!self.isAllowDownLoad){
            ZKProgressHUD.showMessage("该资源不允许下载！")
            return
        }
        let cx = SQLiteManagerCache()
        let path = cx.readOneData(_userId: Account.defaultAccount.id!, docId: self.docId)
        if(path.docPath.isEmpty){
            self.startDownload()
        }else{
            ZKProgressHUD.showMessage("该资源已被下载")
        }
         print("| BMPlayerDelegate | bmPlayerStartDownload")
    }

    //开始下载
    func startDownload(){
        let vc = cacheViewController();
        vc.docId = self.docId
        vc.docUrl = self.videourls.last!
        vc.docType = 1
        vc.docTitle = self.videotittle
        vc.isStart = true;
        self.navigationController?.pushViewController(vc, animated: true);
    }

    // Call when player orinet changed
    func bmPlayer(player: BMPlayer, playerOrientChanged isFullscreen: Bool) {


        player.snp.remakeConstraints { (make) in
            make.top.equalTo(view.snp.top)
            make.left.equalTo(view.snp.left)
            make.right.equalTo(view.snp.right)
            if isFullscreen {
                make.bottom.equalTo(view.snp.bottom)
                for (i,v) in self.view.subviews.enumerated(){
                    if i == 2 || i == 1{
                        v.isHidden = true
                    }
                }
            } else {
                make.height.equalTo(view.snp.width).multipliedBy(9.0/16.0).priority(500)
                for (i,v) in self.view.subviews.enumerated(){
                    if i == 2 || i == 1{
                        v.isHidden = false
                    }
                }
            }
        }
    }

    // Call back when playing state changed, use to detect is playing or not
    func bmPlayer(player: BMPlayer, playerIsPlaying playing: Bool) {
        print("| BMPlayerDelegate | playerIsPlaying | playing - \(playing)")
      
        var dict =
            ["type":"videoEvents",
            "name":"pause",
          
            "cellId":self.docId,
            "courseId":self.courseOpenId]
        if playing{
            dict =
                ["type":"videoEvents",
                 "name":"play",
                 "cellId":self.docId,
                 "courseId":self.courseOpenId,
                 "position":"\(self.leavelocation)"];
        }
        self.emitToPC(dict:dict)
    }

    // Call back when playing state changed, use to detect specefic state like buffering, bufferfinished
    func bmPlayer(player: BMPlayer, playerStateDidChange state: BMPlayerState) {
        print("--------------------| BMPlayerDelegate | playerStateDidChange | state - \(state)")
    }

    // Call back when play time change
    func bmPlayer(player: BMPlayer, playTimeDidChange currentTime: TimeInterval, totalTime: TimeInterval) {
        print("¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥| BMPlayerDelegate | playTimeDidChange | \(currentTime) of \(totalTime)")
        self.Watchtime = currentTime
        if(self.WatchMaxtime  < currentTime - 20){//往前拖了
            print("往前拖了")
        }else{
            self.WatchMaxtime = currentTime
        }

        self.videototalTime = totalTime
        if(self.isNeedUpdate){
            common.share.updateDataByCell(cellId: self.docId, pageNum: 0, seconds: Int(self.videototalTime))
            self.isNeedUpdate = false
        }
    }

    // Call back when the video loaded duration changed
    func bmPlayer(player: BMPlayer, loadedTimeDidChange loadedDuration: TimeInterval, totalDuration: TimeInterval) {
                print("| BMPlayerDelegate | loadedTimeDidChange | \(loadedDuration) of \(totalDuration)")
    }

    func bmPlayer(player: BMPlayer, to: TimeInterval) {
        
        if( self.WatchMaxtime + 10 < to && isStu && !self.isStudyFinish){
            self.player.seek(self.WatchMaxtime)
        }else {
            let  dict =  ["type":"videoEvents",
                          "name":"seek",
                          "cellId":self.docId,
                          "courseId":self.courseOpenId,
                          "position":"\(to)" ] ;
            self.emitToPC(dict:dict )
        }

    }
}

