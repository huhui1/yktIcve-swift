//
//  ipadVideoPlayView.swift
//  云课堂2
//  适配ipad 的视频播放
//  Created by 尤增强 on 2018/7/12.
//  Copyright © 2018年 zqyou. All rights reserved.
//

import UIKit
import BMPlayer
import AVFoundation
import NVActivityIndicatorView
import SwiftyJSON

class ipadVideoPlayView: UIViewController,UITableViewDelegate,UITableViewDataSource{


    @IBOutlet var Bg_view: UIView!
    @IBOutlet var teaching_tableView: UITableView!
    @IBOutlet weak var playViewWHAspect: NSLayoutConstraint!
    @IBOutlet weak var playView: UIView!
    @IBOutlet weak var tableViewW: NSLayoutConstraint!
    var List : JSON =  {
        return []
    }()

    let vc1 = courseBBSEvaluationView()
    let vc2 = courseBBSQuestionView()
    let vc3 = courseBBSNoteView()
    let vc4 = courseBBSErrorView()
    
    var isStu = false
    var slideMenu:SlideMenu?
    let appDelegate = UIApplication.shared.delegate as! AppDelegate
    lazy var courseOpenId:String = ""
    lazy var docId:String = ""
    var openClassId = "";
    var moduleId = ""
    lazy var videoPlayurl:String = ""
    lazy var videotittle:String = ""
    lazy var Watchtime:Double = 0.0//当前观看时长
    lazy var WatchMaxtime:Double = 0.0 //视频观看的最大时长
    lazy var videototalTime:Double = 0.0
    var docvideoleavelist = [KJloctoionModel]();
    lazy var leavelocation:Int = 0     //离开时的位置
    var sqliteContext = SQLiteManagerKJrecord()
    //存储url数组
    lazy var videourls = [String]()
    let  player = BMPlayer()
    var isPushed = false
    var isNeedUpdate = false
    /// 是否允许下载
    var isAllowDownLoad = false
    var  isVoideoFullscreen = false
    var courseBBSAction = CourseBBSAction.init(ActionName: "")
    override func viewDidLoad() {
        super.viewDidLoad()

        self.resetPlayerManager()
        self.courseBBSAction.addObserver(self, forKeyPath: "ActionName", options: [.new, .old], context: nil)
        self.view.backgroundColor = UIColor.colorWithHex(hexColor: 0xf2f2f2)
        self.setVideo()
        self.docvideoleavelist = [sqliteContext.readOneData(_userId: Account.defaultAccount.id!,docId:  self.docId)]
        let item = self.docvideoleavelist[0]
        //        self.leavelocation = item.location //上次离开时的位置
        self.setvideoUrl()
        if Account.defaultAccount.role! != "1"{
            self.setTableView()
            self.getData(isRefresh: true)
        }
        // Do any additional setup after loading the view.
        
    }
    init() {
        super.init(nibName: "ipadVideoPlayView", bundle: nil)
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        UIApplication.shared.setStatusBarStyle(UIStatusBarStyle.default, animated: false)

        self.isPushed = false

        // 使用手势返回的时候，调用下面方法
        player.pause(allowAutoPlay: true)

        let item = self.docvideoleavelist[0]
        if item.id.isEmpty{
            //插入数据
            sqliteContext.insertData(_id: self.docId, _userId:Account.defaultAccount.id!, _location:Int(self.WatchMaxtime))
        }else{
            sqliteContext.updateData(Id: self.docId, _location: Int(self.WatchMaxtime))
        }
        self.navigationController?.navigationBar.isHidden = false
    }

    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)

        self.navigationController?.navigationBar.isHidden = true
        UIApplication.shared.setStatusBarStyle(UIStatusBarStyle.lightContent, animated: false)
        // If use the slide to back, remember to call this method
        // 使用手势返回的时候，调用下面方法
        player.autoPlay()
    }

    //添加监听后,使用完必须移除监听(一个add 对应一个 remove)
    deinit {
        self.courseBBSAction.removeObserver(self, forKeyPath: "ActionName", context: nil)
    }
    
    fileprivate func setVideo(){

        self.playView.addSubview(player)
        player.snp.makeConstraints { (make) in

            make.left.top.height.width.equalTo(self.playView)
        }
        // Back button event
        player.backBlock = { [unowned self] (isFullScreen) in
            if isFullScreen == true && UIDevice.current.model != "iPad" { return }
            let _ = self.navigationController?.popViewController(animated: true)
            let dict = ["type":"closeRes"]
            self.emitToPC(dict:dict)
        }

        player.delegate = self
        self.setSlideMenu()
    }

    func resetPlayerManager() {
        BMPlayerConf.allowLog = false
        BMPlayerConf.shouldAutoPlay = true
        BMPlayerConf.tintColor = UIColor.white
        BMPlayerConf.topBarShowInCase = .always
        BMPlayerConf.loaderType  = NVActivityIndicatorType.ballRotateChase
    }

    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
    
    func numberOfSections(in tableView: UITableView) -> Int {
        // #warning Incomplete implementation, return the number of sections
        return 1
    }
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        // #warning Incomplete implementation, return the number of rows
        return self.List.count
    }
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        return 142
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
    
        let cell = tableView.dequeueReusableCell(withIdentifier: "ipadCourseTeachsCell", for: indexPath) as! CourseTeachsCell
        let data = JSON(self.List[indexPath.row])
        //去除点击cell变灰
        cell.selectionStyle = UITableViewCellSelectionStyle.none
        
        cell.ishaddencourseName = false
        cell.setjson(json: data)
        cell.btn_editor.tag = indexPath.row
                cell.btn_editor.addTarget(self, action: #selector(self.edittapped(_:)), for: .touchUpInside)
        return cell
    }
    
    
    //跳转到活动
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        let json = self.List[indexPath.row];
        let vc = faceInfoView();
        vc.faceTimeStatus = json["State"].intValue
        vc.activityId = json["Id"].stringValue;
        vc.courseOpenId =  json["CourseOpenId"].stringValue;
        vc.openClassIds = json["OpenClassIds"].stringValue
        self.isPushed = true
        self.navigationController?.pushViewController(vc, animated: true);
        
    }
    //编辑
    @objc func edittapped(_ button:UIButton){
        let tag = button.tag;
        let json = JSON(self.List[tag])
        let vc = createFaceView()
        vc.activityId = json["Id"].stringValue;
        vc.openClassId = json["OpenClassIds"].stringValue;
        vc.courseOpenId = json["CourseOpenId"].stringValue;
        vc.textTitle.text = json["Title"].stringValue;
        vc.textPlace.text = json["Address"].stringValue;
        vc.startDtae.text = json["StartTime"].stringValue;
        vc.ClassSection.text = json["ClassSection"].stringValue
        vc.reloadViewClosure = { () in
            self.getData(isRefresh: false)
        };
        vc.hidesBottomBarWhenPushed = true
        self.navigationController?.pushViewController(vc, animated: true);
    }
    /*
    // MARK: - Navigation

    // In a storyboard-based application, you will often want to do a little preparation before navigation
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        // Get the new view controller using segue.destinationViewController.
        // Pass the selected object to the new view controller.
    }
    */

}
// MARK:- BMPlayerDelegate example
extension ipadVideoPlayView: BMPlayerDelegate {


    func bmPlayerStartDownload() {
        if(!self.isAllowDownLoad){
            ZKProgressHUD.showMessage("该资源不允许下载！")
            return
        }
        let cx = SQLiteManagerCache()
        let path = cx.readOneData(_userId: Account.defaultAccount.id!, docId: self.docId)
        if(path.docPath.isEmpty){
            self.startDownload()
        }else{
            ZKProgressHUD.showMessage("该资源已被下载")
        }
        print("| BMPlayerDelegate | bmPlayerStartDownload")
    }

    //开始下载
    func startDownload(){
        let vc = cacheViewController();
        vc.docId = self.docId
        vc.docUrl = self.videourls.last!
        vc.docType = 1
        vc.docTitle = self.videotittle
        vc.isStart = true;
        self.navigationController?.pushViewController(vc, animated: true);
    }

    // Call when player orinet changed
    func bmPlayer(player: BMPlayer, playerOrientChanged isFullscreen: Bool) {
        self.isVoideoFullscreen = !self.isVoideoFullscreen
        if  self.isVoideoFullscreen {

           self.view.addSubview(self.player)
            player.snp.remakeConstraints { (make) in
                make.left.top.equalTo(self.view)
                make.height.equalTo(UIScreen.main.bounds.height)
                make.width.equalTo(UIScreen.main.bounds.width)
            }

        }else{
            self.playView.addSubview(player)
             player.snp.remakeConstraints { (make) in

                make.left.top.height.width.equalTo(self.playView)
            }

        }
    }

    // Call back when playing state changed, use to detect is playing or not
    func bmPlayer(player: BMPlayer, playerIsPlaying playing: Bool) {
        print("| BMPlayerDelegate | playerIsPlaying | playing - \(playing)")

        var dict =
            ["type":"videoEvents",
             "name":"pause",

             "cellId":self.docId,
             "courseId":self.courseOpenId]
        if playing{
            dict =
                ["type":"videoEvents",
                 "name":"play",
                 "cellId":self.docId,
                 "courseId":self.courseOpenId,
                 "position":"\(self.leavelocation)"];
        }
        self.emitToPC(dict:dict)
    }

    // Call back when playing state changed, use to detect specefic state like buffering, bufferfinished
    func bmPlayer(player: BMPlayer, playerStateDidChange state: BMPlayerState) {
        print("--------------------| BMPlayerDelegate | playerStateDidChange | state - \(state)")
    }

    // Call back when play time change
    func bmPlayer(player: BMPlayer, playTimeDidChange currentTime: TimeInterval, totalTime: TimeInterval) {
        //   print("| BMPlayerDelegate | playTimeDidChange | \(currentTime) of \(totalTime)")
        self.Watchtime = currentTime
        if self.WatchMaxtime < currentTime{
            self.WatchMaxtime = currentTime
        }
        self.videototalTime = totalTime
    }

    // Call back when the video loaded duration changed
    func bmPlayer(player: BMPlayer, loadedTimeDidChange loadedDuration: TimeInterval, totalDuration: TimeInterval) {
        print("| BMPlayerDelegate | loadedTimeDidChange | \(loadedDuration) of \(totalDuration)")
    }

    func bmPlayer(player: BMPlayer, to: TimeInterval) {

        if( self.WatchMaxtime + 10 < to && isStu){
            self.player.seek(self.WatchMaxtime)
        }else {
            let  dict =  ["type":"videoEvents",
                          "name":"seek",
                          "cellId":self.docId,
                          "courseId":self.courseOpenId,
                          "position":"\(to)" ] ;
            self.emitToPC(dict:dict )
        }
    }
}

