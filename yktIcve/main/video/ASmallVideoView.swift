//
//  ASmallVideoView.swift
//  云课堂2
//
//  Created by 尤增强 on 2018/6/6.
//  Copyright © 2018年 zqyou. All rights reserved.
//

import UIKit
import AVFoundation
import Photos
import BMPlayer
class ASmallVideoView: UIViewController,AVCaptureFileOutputRecordingDelegate {

    var oProgressView = OProgressView()
    var Label_time = UILabel()
    var btn_back = UIButton()
    let captureSession = AVCaptureSession()
    //视频输入设备
    let videoDevice = AVCaptureDevice.default(for: AVMediaType.video)
    //音频输入设备
    let audioDevice = AVCaptureDevice.default(for: AVMediaType.audio)
    //将捕获到的视频输出到文件
    let fileOutput = AVCaptureMovieFileOutput()

    //开始、停止按钮
    var startButton, stopButton : UIButton!
    //表示当时是否在录像中
    var isRecording = false

    override func viewDidLoad() {
        super.viewDidLoad()
//        self.navigationController?.navigationBar.isHidden = true
        self.setUI()
        // Do any additional setup after loading the view.
    }

   fileprivate func setUI(){


        let videoInput = try! AVCaptureDeviceInput(device: self.videoDevice!)
        self.captureSession.addInput(videoInput)
        let audioInput = try! AVCaptureDeviceInput(device: self.audioDevice!)
        self.captureSession.addInput(audioInput);

        //添加视频捕获输出
        self.captureSession.addOutput(self.fileOutput)

        //使用AVCaptureVideoPreviewLayer可以将摄像头的拍摄的实时画面显示在ViewController上
        let videoLayer = AVCaptureVideoPreviewLayer(session: self.captureSession)
        videoLayer.frame =  self.view.bounds
        videoLayer.videoGravity = AVLayerVideoGravity.resizeAspectFill
        self.view.layer.addSublayer(videoLayer)

        let o =  UIApplication.shared
            .statusBarOrientation

        if(o ==  UIInterfaceOrientation.landscapeRight )
        {
            videoLayer.connection?
                .videoOrientation = .landscapeRight; //左转90
        }
        //启动session会话
        self.captureSession.startRunning()
        oProgressView.isUserInteractionEnabled = true
        //长按监听
        let longPress = UILongPressGestureRecognizer(target:self,
                                                     action:#selector(longtap(_:)))
        self.view.addGestureRecognizer(longPress)

        self.oProgressView.frame.size = CGSize.init(width: 80, height: 80)
        self.Label_time.frame.size =  CGSize.init(width: 40, height: 20)
        self.Label_time.textColor = UIColor.white
        if(UIDevice.current.model == "iPad"){
            self.oProgressView.center = CGPoint.init(x: UIScreen.main.bounds.width  - 60, y: UIScreen.main.bounds.height / 2)
            self.Label_time.center = CGPoint.init(x:  UIScreen.main.bounds.width  - 100, y:  UIScreen.main.bounds.height / 2)
        }else {
             self.oProgressView.center = CGPoint.init(x: UIScreen.main.bounds.width / 2, y: UIScreen.main.bounds.height - 60)
            self.Label_time.center = CGPoint.init(x:  UIScreen.main.bounds.width / 2, y:  UIScreen.main.bounds.height - 110)
        }

        self.btn_back.frame = CGRect.init(x: UIScreen.main.bounds.width - 60, y: 20, width: 50, height: 50)
        self.btn_back.setTitle("\u{e606}", for: .normal)
        self.btn_back.titleLabel?.font = UIFont.init(name: "iconfont", size: 36)
        self.btn_back.setTitleColor(UIColor.lightGray, for: .normal)
        self.Label_time.font = UIFont.init(name: "iconfont", size: 12)
        self.oProgressView.backgroundColor = UIColor.clear
        self.view.addSubview( self.oProgressView)
        self.view.addSubview(self.Label_time)
        self.view.addSubview(self.btn_back)
        self.btn_back.addTarget(self, action: #selector(self.backCancel), for: .touchUpInside)
    }

    @objc func longtap(_ sender: UILongPressGestureRecognizer) {

        if sender.state == .began {
            print("长按响应开始")
            self.setTime()
            self.onClickStartButton()
        } else if sender.state == .ended {
            print("长按响应结束")
             self.codeTimer?.cancel()
            self.onClickStopButton()
        }
    }

     @objc func backCancel(){

       self.dismiss(animated: true, completion: nil)
    }

    func setTime(){

        // 在global线程里创建一个时间源
        codeTimer = DispatchSource.makeTimerSource(queue:  DispatchQueue.global())
        // 设定这个时间源是每秒循环一次，立即开始
        codeTimer?.schedule(deadline: .now(), repeating:.milliseconds(200))
        // 设定时间源的触发事件
        codeTimer?.setEventHandler(handler: {
            if(self.oProgressView.progress == 100){
                self.codeTimer?.cancel()
            }
            self.Time += 200

            print(self.Time)
            // 返回主线程处理一些事件，更新UI等等
            DispatchQueue.main.async {
                 self.Label_time.text = "\(self.Time / 1000)秒"
                self.oProgressView.setProgress(self.oProgressView.progress + 2, animated: true)
            }
        })
        // 启动时间源
        codeTimer?.resume()
    }

    //录像结束的代理方法
    func fileOutput(_ output: AVCaptureFileOutput,
                    didFinishRecordingTo outputFileURL: URL,
                    from connections: [AVCaptureConnection], error: Error?) {
        var message:String!
        //将录制好的录像保存到照片库中
//        PHPhotoLibrary.shared().performChanges({
//            PHAssetChangeRequest.creationRequestForAssetFromVideo(atFileURL: outputFileURL)
//        }, completionHandler: { (isSuccess: Bool, error: Error?) in
//            if isSuccess {
//                message = "保存成功!"
//            } else{
//                message = "保存失败：\(error!.localizedDescription)"
//            }
//
//            DispatchQueue.main.async {
//                //弹出提示框
//                let alertController = UIAlertController(title: message, message: nil,
//                                                        preferredStyle: .alert)
//                let cancelAction = UIAlertAction(title: "确定", style: .cancel, handler: nil)
//                alertController.addAction(cancelAction)
//                self.present(alertController, animated: true, completion: nil)
//            }
//        })

        let vc = ASmallVideoPreviewView()
        vc.videoURL = outputFileURL

        self.present(vc, animated: true, completion: {
            self.oProgressView.setProgress(0, animated: true)
            self.Label_time.text = ""
        })
    }


   


    //开始按钮点击，开始录像
    @objc func onClickStartButton(){
        if !self.isRecording {
            //设置录像的保存地址（在Documents目录下，名为temp.mp4）
            let paths = NSSearchPathForDirectoriesInDomains(.documentDirectory,
                                                            .userDomainMask, true)
            let documentsDirectory = paths[0] as String
            let filePath = "\(documentsDirectory)/temp.mp4"
            let fileURL = URL(fileURLWithPath: filePath)
            //启动视频编码输出
            fileOutput.startRecording(to: fileURL, recordingDelegate: self)

            //记录状态：录像中...
            self.isRecording = true


        }
    }

    //停止按钮点击，停止录像
    @objc func onClickStopButton(){
        if self.isRecording {
            //停止视频编码输出
            fileOutput.stopRecording()

            //记录状态：录像结束
            self.isRecording = false

        }
    }
    

    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }

    lazy var Time :Int = {
        return 0
    }()

    var codeTimer: DispatchSourceTimer?
    /*
    // MARK: - Navigation

    // In a storyboard-based application, you will often want to do a little preparation before navigation
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        // Get the new view controller using segue.destinationViewController.
        // Pass the selected object to the new view controller.
    }
    */

}
