/**
 * @name     canvas 标记
 * @author   M.J
 * @depend   jQuery || Zepto
 * @date     2015-09-18
 * @URL      http://webjyh.com
 * @version  1.0.0
 * @license  MIT
 *
 * @PS If you have any questions, please don't look for me, I don't know anything. thank you.
 */
(function($) {
    //  默认配置项
    var defaults = {
            canvas: null,
            color: 'rgb(237, 69, 59)',
            style: {},
            line: {
                Width: 1,
                Jons: 'round',
                Cep: 'round'
            },
            before: function() {
                
            },
            move: function() {

            },
            after: function() {

            }
        };

    // 日志输出
    var log = function(msg, type) {
        type = type || 'log';
        if (window.console) {
            console[type](msg);
        }
    };

    // 构造函数
    var Mark = function(options) {
        return new Mark.fn.init(options);
    };

    Mark.fn = Mark.prototype = {
        constructor: Mark,
        /**
         * 默认载入
         * @return this
         */
        init: function(options) {
            var key,
                isMobile = true;

            this.config = this.extend({}, defaults, options);
            if (!this.config.canvas) {
                log('config.canvas is not defined', 'error');
                return this;
            }

            // 创建 canvas
            this.canvas = this.config.canvas;
            this.context = this.canvas.getContext && this.canvas.getContext('2d');

            if (!this.context) {
                log('您当前的浏览器不支持 Canvas！');
                return this;
            }

            // 设置
            for (key in this.config.line) {
                this.context['line' + key] = this.config.line[key];
            }
            
            this.lineSize = 1;
            this.context.globalCompositeOperation = "source-over";
            this.context.strokeStyle = this.config.color;
            this.historyStroker = [];
            this.currentStroker = {type: 'pen', color: this.config.color, width: this.context.lineWidth, path:[]};
            this.currentEraser = {type: 'eraser', width: 30, height: 30, path: []};
            this.lastX = 0;
            this.lastY = 0;
            this.isButtonDown = false;
            this.isMobile = isMobile;
            this.isEraser = false; // 是否是橡皮擦模式

            this.e = {
                mousedown: isMobile ? 'touchstart' : 'mousedown',
                mousemove: isMobile ? 'touchmove' : 'mousemove',
                mouseup: isMobile ? 'touchend' : 'mouseup'
            };

            // 载入 绑定事件
            this.events();

            return this;
        },

        /**
         * 设置笔刷颜色
         * @return this;
         */
        setColor: function(color) {
            this.config.color = color;
            this.context.strokeStyle = color;
            return this;
        },

        /**
         * 设置笔刷粗细
         * @return this;
         */
        setLineWidth: function(size) {
            var width;

            switch (size) {
                case 'small': width = 1; break;
                case 'middle': width = 3; break;
                case 'large': width = 6; break;
                default: width = size;
            }

            this.lineSize = width;
            this.context.lineWidth = width;

            return this;
        },

        /**
         * 清空画板
         * @return this;
         */
        empty: function() {
            this.historyStroker = [];
            this.clear();
            return this;
        },

        /**
         * 设置模式
         * @return this;
         */
        setMethod: function(val) {
            this.isEraser = val == 'eraser' ? true : false;
            this.context.globalCompositeOperation = (this.isEraser ? "destination-out" : "source-over");
            this.context.lineWidth = this.isEraser ? 10 : this.lineSize;
            return this;
        },

        /**
         * 绑定事件
         * @return this;
         */
        events: function() {
            var _this = this,
                $elem = $(this.canvas),
                $img = $elem.next(),
                $parent = $(this.canvas.parentNode.parentNode),
                pW = parseInt(document.defaultView.getComputedStyle($parent[0], false)['width'], 10),
                pH = parseInt(document.defaultView.getComputedStyle($parent[0], false)['height'], 10),
                w = $img.length ? (parseInt($img.css('width'), 10)) : pW,
                h = $img.length ? (parseInt($img.css('height'), 10)) : pH,
                diffX = 0,
                diffY = 0;

            var action = function(e) {
                var type = e.type,
                    clientX = _this.isMobile ? e.changedTouches[0].clientX : e.clientX,
                    clientY = _this.isMobile ? e.changedTouches[0].clientY : e.clientY,
                    key, x, y;

                    x = clientX  - Math.abs(diffX);
                    y = clientY  - (diffY + 40);

                if (e.touches.length > 1) {
                    return this;
                }

                switch (type) {
                    case 'touchstart':
                    case 'mousedown': key = 'mousedown'; break;
                    case 'touchmove':
                    case 'mousemove': key = 'mousemove'; break;
                    case 'touchend':
                    case 'mouseup': key = 'mouseup'; break;
                }

                if (!key) return;

                _this[key](e, {x: x, y: y}, {diffX: diffX, diffY: diffY});
            }

            // 按下
            $elem.off(this.e.mousedown).on(this.e.mousedown, action);
            $elem.off(this.e.mousemove).on(this.e.mousemove, action);
            $elem.off(this.e.mouseup).on(this.e.mouseup, action);

            return this;
        },

        /**
         * 按下画笔操作
         * @params event   点击事件
         * @params offset  每次更新的画笔位置
         * @return this;
         */
        mousedown: function(e, offset, diff) {
            if (!this.isMobile && e.button !== 0) {
                return this;
            }

            // 更新画笔在画布位置
            this.isButtonDown = true;
            this.lastX = offset.x;
            this.lastY = offset.y;

            // 开始操作画笔
            this.context.beginPath();
            this.context.moveTo(this.lastX, this.lastY);
            this.currentStroker.width = this.context.lineWidth;
            this.currentStroker.color = this.config.color;
            this[this.isEraser ? 'currentEraser' : 'currentStroker'].path.push(offset);

            // 执行画笔回调
            this.config.before && this.config.before.apply(this, [diff]);

            return this;
        },

        /**
         * 移动画笔操作
         * @params event
         * @params offset  每次更新的画笔位置
         * @return this;
         */
        mousemove: function(e, offset, diff) {
            if (!this.isButtonDown) {
                return this;
            }
            
            // 继续上一次做画
            this.context.quadraticCurveTo(this.lastX, this.lastY, (offset.x + this.lastX) / 2, (offset.y + this.lastY) / 2);
            this.context.stroke();
            this.lastX = offset.x;
            this.lastY = offset.y;
            this[this.isEraser ? 'currentEraser' : 'currentStroker'].path.push(offset);

            // 执行画笔回调
            this.config.move && this.config.move.apply(this, [diff]);

            return this;
        },

        /**
         * 画笔操作结束
         * @params event
         * @params offset  每次更新的画笔位置
         * @return this;
         */
        mouseup: function(e, offset, diff) {
            if (!this.isMobile && e.button !== 0) {
                return this;
            }
            
            this.isButtonDown = false;
            this.context.lineTo(offset.x, offset.y);
            this.context.closePath();
            this.historyStroker.push(this[this.isEraser ? 'currentEraser' : 'currentStroker']);
            this.currentStroker = {type: 'pen', color:this.config.color, width: this.context.lineWidth, path:[]};
            this.currentEraser = {type: 'eraser', width: 30, height: 30, path:[]};

            // 执行画笔回调
            this.config.after && this.config.after.apply(this, [diff]);

            return this;
        },

        /**
         * 橡皮擦工具
         * @return this;
         */
        clearRect: function(x, y) {
            this.context.clearRect(x, y, 30, 30);
            return this;
        },

        /**
         * 清除画布
         * @return this;
         */
        clear: function() {
            this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
            return this;
        },

        /**
         * 重绘路径
         * @return this;
         */
        redraw: function() {
            if (!this.historyStroker.length) {
                return this;
            }

            var i = 0,
                cxt = this.context,
                history = this.historyStroker,
                length = history.length;

            for (; i < length; i++) {
                var val = history[i],
                    temp;

                if (!val.path.length) {
                    continue;
                }
  
                // 设置画笔
                cxt.globalCompositeOperation = (val.type === 'pen' ? "source-over" : "destination-out");
                cxt.lineWidth = val.type === 'pen' ? val.width : 10;
                cxt.strokeStyle = val.color;
                cxt.beginPath();
                cxt.moveTo(val.path[0].x, val.path[0].y);
                
                // 存储上一次的直
                temp = {x: val.path[0].x, y: val.path[0].y};

                // 操作路径
                for (var j = 0; j < val.path.length; j++) {
                    cxt.quadraticCurveTo(temp.x, temp.y, (val.path[j].x + temp.x) / 2, (val.path[j].y + temp.y) / 2);
                    //cxt.lineTo(val.path[j].x, val.path[j].y);
                    cxt.stroke();
                    temp = {x: val.path[j].x, y: val.path[j].y}
                }
                    
                cxt.closePath();
            }

            return this;
        },

        /**
         * 撤销上一次操作记录
         * @return this;
         */
        undo: function() {
            if (!this.historyStroker.length) {
                return this.historyStroker.length;
            }

            // 移除最后一次记录
            this.historyStroker.pop();
            this.clear().redraw();

            return this.historyStroker.length;
        }
    };

    Mark.fn.init.prototype = Mark.fn;

    /**
     * 合并对象（不支持深度copy）
     * 如果只给第一个参数，则扩展至 Mark 命名空间，
     * @type {Function}
     * @return {Object}
     */
    Mark.extend = Mark.fn.extend = function() {
        var copy, options, name,
            target = arguments[0] || {},
            i = 1,
            length = arguments.length,
            deep = false;

        // 处理一些异常情况
        if (typeof target !== "object" && typeof target !== 'function') {
            target = {};
        }

        // 如果 arguments == 1 则给当前 Mark 命名空间添加
        if (length === i) {
            target = this;
            --i;
        }

        // 遍历处理
        for (; i < length; i++) {
            if ((options = arguments[i]) != null) {
                for (name in options) {
                    copy = options[name];

                    if (target === copy) {
                        continue;
                    }

                    if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }

        return target;
    };

    window.Mark =  Mark;
}(window[window.$$ ? '$$' : 'Zepto']));